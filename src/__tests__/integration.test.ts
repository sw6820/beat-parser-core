import { BeatParser, BeatParserPlugin } from '../core/BeatParser';\nimport { BeatCandidate } from '../types';\nimport fs from 'fs/promises';\nimport path from 'path';\n\ndescribe('BeatParser Integration Tests', () => {\n  let parser: BeatParser;\n  const testDataDir = path.join(__dirname, '../../test-data');\n  \n  beforeEach(() => {\n    parser = new BeatParser();\n  });\n  \n  afterEach(async () => {\n    await parser.cleanup();\n  });\n\n  describe('End-to-End Parsing Workflow', () => {\n    const createTestAudio = (duration: number, bpm: number): Float32Array => {\n      const sampleRate = 44100;\n      const samples = Math.floor(duration * sampleRate);\n      const audio = new Float32Array(samples);\n      \n      // Generate audio with clear beats at specified BPM\n      const beatInterval = (60 / bpm) * sampleRate; // samples per beat\n      const beatDuration = sampleRate * 0.1; // 100ms beat duration\n      \n      for (let i = 0; i < samples; i++) {\n        const beatPhase = i % beatInterval;\n        if (beatPhase < beatDuration) {\n          // Create a simple beat pulse (sine wave with exponential decay)\n          const t = beatPhase / sampleRate;\n          const frequency = 60; // 60 Hz kick drum frequency\n          const decay = Math.exp(-t * 30); // Exponential decay\n          audio[i] = Math.sin(2 * Math.PI * frequency * t) * decay * 0.8;\n        } else {\n          // Add some background noise\n          audio[i] = (Math.random() - 0.5) * 0.05;\n        }\n      }\n      \n      return audio;\n    };\n\n    test('should parse simple 120 BPM audio', async () => {\n      const testAudio = createTestAudio(5, 120); // 5 seconds at 120 BPM\n      \n      const result = await parser.parseBuffer(testAudio, {\n        targetPictureCount: 10\n      });\n      \n      expect(result).toBeDefined();\n      expect(result.beats).toBeDefined();\n      expect(result.beats.length).toBeGreaterThan(0);\n      expect(result.beats.length).toBeLessThanOrEqual(10);\n      \n      // Check that beats are reasonably spaced (around 0.5s for 120 BPM)\n      if (result.beats.length > 1) {\n        const intervals = [];\n        for (let i = 1; i < result.beats.length; i++) {\n          intervals.push(result.beats[i].timestamp - result.beats[i - 1].timestamp);\n        }\n        const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;\n        expect(avgInterval).toBeGreaterThan(0.3); // At least 0.3s\n        expect(avgInterval).toBeLessThan(0.7); // At most 0.7s\n      }\n    });\n\n    test('should handle different audio formats and edge cases', async () => {\n      const testCases = [\n        { duration: 1, bpm: 60, description: 'slow tempo' },\n        { duration: 10, bpm: 140, description: 'fast tempo' },\n        { duration: 0.5, bpm: 120, description: 'very short audio' },\n        { duration: 3, bpm: 90, description: 'moderate tempo' }\n      ];\n      \n      for (const testCase of testCases) {\n        const testAudio = createTestAudio(testCase.duration, testCase.bpm);\n        \n        const result = await parser.parseBuffer(testAudio, {\n          targetPictureCount: Math.max(1, Math.floor(testCase.duration))\n        });\n        \n        expect(result.beats).toBeDefined();\n        expect(result.beats.length).toBeGreaterThan(0);\n        \n        // All beats should have valid timestamps\n        result.beats.forEach((beat, index) => {\n          expect(beat.timestamp).toBeGreaterThanOrEqual(0);\n          expect(beat.timestamp).toBeLessThanOrEqual(testCase.duration);\n          expect(beat.confidence).toBeGreaterThanOrEqual(0);\n          expect(beat.confidence).toBeLessThanOrEqual(1);\n          \n          // Beats should be sorted by timestamp\n          if (index > 0) {\n            expect(beat.timestamp).toBeGreaterThanOrEqual(result.beats[index - 1].timestamp);\n          }\n        });\n      }\n    });\n\n    test('should validate picture count selection functionality', async () => {\n      const testAudio = createTestAudio(10, 120); // 10 seconds, should have ~20 beats\n      \n      const testCounts = [1, 5, 10, 15, 25, 50];\n      \n      for (const targetCount of testCounts) {\n        const result = await parser.parseBuffer(testAudio, {\n          targetPictureCount: targetCount\n        });\n        \n        expect(result.beats.length).toBeGreaterThan(0);\n        expect(result.beats.length).toBeLessThanOrEqual(targetCount);\n        \n        // If we request more beats than available, we should get all available beats\n        if (targetCount >= 20) {\n          expect(result.beats.length).toBeGreaterThan(10); // Should have most beats\n        }\n        \n        // If we request fewer beats, we should get exactly that number or fewer\n        if (targetCount <= 5) {\n          expect(result.beats.length).toBeLessThanOrEqual(targetCount);\n        }\n      }\n    });\n\n    test('should generate valid JSON output format', async () => {\n      const testAudio = createTestAudio(3, 120);\n      \n      const result = await parser.parseBuffer(testAudio, {\n        targetPictureCount: 5\n      });\n      \n      // Validate JSON structure\n      expect(result).toHaveProperty('beats');\n      expect(result).toHaveProperty('metadata');\n      expect(Array.isArray(result.beats)).toBe(true);\n      \n      // Validate beat structure\n      result.beats.forEach(beat => {\n        expect(beat).toHaveProperty('timestamp');\n        expect(beat).toHaveProperty('confidence');\n        expect(typeof beat.timestamp).toBe('number');\n        expect(typeof beat.confidence).toBe('number');\n        expect(beat.confidence).toBeGreaterThanOrEqual(0);\n        expect(beat.confidence).toBeLessThanOrEqual(1);\n      });\n      \n      // Validate metadata structure\n      expect(result.metadata).toHaveProperty('processingInfo');\n      expect(result.metadata.processingInfo).toHaveProperty('audioLength');\n      expect(result.metadata.processingInfo).toHaveProperty('sampleRate');\n      expect(result.metadata.processingInfo).toHaveProperty('algorithmsUsed');\n    });\n\n    test('should handle error cases gracefully', async () => {\n      // Empty audio data\n      await expect(parser.parseBuffer(new Float32Array(0))).rejects.toThrow();\n      \n      // Invalid audio data\n      const invalidAudio = new Float32Array(1000);\n      invalidAudio.fill(NaN);\n      await expect(parser.parseBuffer(invalidAudio)).rejects.toThrow();\n      \n      // Audio too short\n      const tooShort = new Float32Array(100); // Less than frameSize\n      await expect(parser.parseBuffer(tooShort)).rejects.toThrow();\n    });\n  });\n\n  describe('Configuration and Customization', () => {\n    test('should use custom configuration', async () => {\n      const customParser = new BeatParser({\n        minTempo: 80,\n        maxTempo: 160,\n        confidenceThreshold: 0.8,\n        outputFormat: 'json',\n        includeMetadata: true\n      });\n      \n      const config = customParser.getConfig();\n      expect(config.minTempo).toBe(80);\n      expect(config.maxTempo).toBe(160);\n      expect(config.confidenceThreshold).toBe(0.8);\n      expect(config.outputFormat).toBe('json');\n      expect(config.includeMetadata).toBe(true);\n      \n      await customParser.cleanup();\n    });\n\n    test('should support configuration updates', async () => {\n      parser.updateConfig({\n        minTempo: 70,\n        maxTempo: 180,\n        genreAdaptive: false\n      });\n      \n      const config = parser.getConfig();\n      expect(config.minTempo).toBe(70);\n      expect(config.maxTempo).toBe(180);\n      expect(config.genreAdaptive).toBe(false);\n    });\n\n    test('should prevent configuration updates after initialization', async () => {\n      const testAudio = new Float32Array(4096).fill(0.1);\n      await parser.parseBuffer(testAudio); // This initializes the parser\n      \n      expect(() => {\n        parser.updateConfig({ minTempo: 50 });\n      }).toThrow();\n    });\n  });\n\n  describe('Plugin System', () => {\n    const createTestPlugin = (name: string): BeatParserPlugin => ({\n      name,\n      version: '1.0.0',\n      initialize: jest.fn(),\n      processAudio: jest.fn((audio) => audio),\n      processBeats: jest.fn((beats) => beats),\n      cleanup: jest.fn()\n    });\n\n    test('should register and manage plugins', () => {\n      const plugin1 = createTestPlugin('test-plugin-1');\n      const plugin2 = createTestPlugin('test-plugin-2');\n      \n      parser.addPlugin(plugin1);\n      parser.addPlugin(plugin2);\n      \n      const plugins = parser.getPlugins();\n      expect(plugins).toHaveLength(2);\n      expect(plugins[0].name).toBe('test-plugin-1');\n      expect(plugins[1].name).toBe('test-plugin-2');\n      \n      parser.removePlugin('test-plugin-1');\n      const remainingPlugins = parser.getPlugins();\n      expect(remainingPlugins).toHaveLength(1);\n      expect(remainingPlugins[0].name).toBe('test-plugin-2');\n    });\n\n    test('should prevent duplicate plugin names', () => {\n      const plugin1 = createTestPlugin('duplicate-plugin');\n      const plugin2 = createTestPlugin('duplicate-plugin');\n      \n      parser.addPlugin(plugin1);\n      expect(() => parser.addPlugin(plugin2)).toThrow();\n    });\n\n    test('should call plugin lifecycle methods', async () => {\n      const plugin = createTestPlugin('lifecycle-plugin');\n      parser.addPlugin(plugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.1);\n      await parser.parseBuffer(testAudio);\n      \n      expect(plugin.initialize).toHaveBeenCalledWith(parser.getConfig());\n      expect(plugin.processAudio).toHaveBeenCalled();\n      expect(plugin.processBeats).toHaveBeenCalled();\n      \n      await parser.cleanup();\n      expect(plugin.cleanup).toHaveBeenCalled();\n    });\n\n    test('should process audio through plugins', async () => {\n      const plugin: BeatParserPlugin = {\n        name: 'audio-processor',\n        version: '1.0.0',\n        processAudio: jest.fn((audio) => {\n          // Apply a simple transformation\n          const processed = new Float32Array(audio.length);\n          for (let i = 0; i < audio.length; i++) {\n            processed[i] = audio[i] * 0.5; // Reduce amplitude by half\n          }\n          return processed;\n        })\n      };\n      \n      parser.addPlugin(plugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.8);\n      await parser.parseBuffer(testAudio);\n      \n      expect(plugin.processAudio).toHaveBeenCalled();\n      const processedAudio = (plugin.processAudio as jest.Mock).mock.results[0].value;\n      expect(processedAudio[0]).toBe(0.4); // Should be half of original\n    });\n\n    test('should process beats through plugins', async () => {\n      const plugin: BeatParserPlugin = {\n        name: 'beat-processor',\n        version: '1.0.0',\n        processBeats: jest.fn((beats) => {\n          // Boost confidence of all beats\n          return beats.map(beat => ({\n            ...beat,\n            confidence: Math.min(beat.confidence * 1.2, 1)\n          }));\n        })\n      };\n      \n      parser.addPlugin(plugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.1);\n      // Add some simple beats\n      for (let i = 0; i < testAudio.length; i += 1000) {\n        testAudio[i] = 0.8;\n      }\n      \n      await parser.parseBuffer(testAudio);\n      \n      expect(plugin.processBeats).toHaveBeenCalled();\n    });\n  });\n\n  describe('Streaming Support', () => {\n    const createAudioStream = (chunks: Float32Array[]): AsyncIterableIterator<Float32Array> => {\n      let index = 0;\n      return {\n        async next() {\n          if (index >= chunks.length) {\n            return { done: true, value: undefined };\n          }\n          return { done: false, value: chunks[index++] };\n        },\n        [Symbol.asyncIterator]() {\n          return this;\n        }\n      };\n    };\n\n    test('should process audio streams', async () => {\n      const chunkSize = 4096;\n      const chunks = [\n        new Float32Array(chunkSize).fill(0.1),\n        new Float32Array(chunkSize).fill(0.2),\n        new Float32Array(chunkSize).fill(0.1)\n      ];\n      \n      // Add some beats to the chunks\n      for (let i = 0; i < chunks.length; i++) {\n        for (let j = 0; j < chunkSize; j += 1000) {\n          chunks[i][j] = 0.8;\n        }\n      }\n      \n      const stream = createAudioStream(chunks);\n      const result = await parser.parseStream(stream, {\n        chunkSize: chunkSize,\n        targetPictureCount: 5\n      });\n      \n      expect(result.beats).toBeDefined();\n      expect(result.beats.length).toBeGreaterThan(0);\n      expect(result.beats.length).toBeLessThanOrEqual(5);\n      \n      // Verify metadata includes streaming info\n      expect(result.metadata.processingInfo.algorithmsUsed).toContain('streaming');\n      expect(result.metadata.processingInfo).toHaveProperty('chunksProcessed');\n    });\n\n    test('should handle stream progress callbacks', async () => {\n      const chunkSize = 4096;\n      const chunks = [\n        new Float32Array(chunkSize).fill(0.1),\n        new Float32Array(chunkSize).fill(0.2)\n      ];\n      \n      const progressCallback = jest.fn();\n      const stream = createAudioStream(chunks);\n      \n      await parser.parseStream(stream, {\n        chunkSize: chunkSize,\n        progressCallback\n      });\n      \n      expect(progressCallback).toHaveBeenCalledTimes(2);\n      expect(progressCallback).toHaveBeenCalledWith(chunkSize);\n      expect(progressCallback).toHaveBeenCalledWith(chunkSize * 2);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    test('should handle file not found errors', async () => {\n      await expect(parser.parseFile('/nonexistent/file.wav')).rejects.toThrow('Audio file not found');\n    });\n\n    test('should handle unsupported file formats', async () => {\n      await expect(parser.parseFile('/path/to/file.xyz')).rejects.toThrow('Unsupported audio format');\n    });\n\n    test('should validate supported formats', () => {\n      const formats = BeatParser.getSupportedFormats();\n      expect(formats).toContain('.wav');\n      expect(formats).toContain('.mp3');\n      expect(formats).toContain('.flac');\n      expect(formats).toContain('.ogg');\n      expect(formats).toContain('.m4a');\n    });\n\n    test('should provide version information', () => {\n      const version = BeatParser.getVersion();\n      expect(typeof version).toBe('string');\n      expect(version).toMatch(/^\\d+\\.\\d+\\.\\d+$/);\n    });\n\n    test('should handle plugin initialization errors gracefully', async () => {\n      const faultyPlugin: BeatParserPlugin = {\n        name: 'faulty-plugin',\n        version: '1.0.0',\n        initialize: jest.fn().mockRejectedValue(new Error('Plugin initialization failed'))\n      };\n      \n      parser.addPlugin(faultyPlugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.1);\n      await expect(parser.parseBuffer(testAudio)).rejects.toThrow('Failed to initialize BeatParser');\n    });\n\n    test('should handle plugin processing errors gracefully', async () => {\n      const faultyPlugin: BeatParserPlugin = {\n        name: 'faulty-processor',\n        version: '1.0.0',\n        processAudio: jest.fn().mockRejectedValue(new Error('Audio processing failed'))\n      };\n      \n      parser.addPlugin(faultyPlugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.1);\n      await expect(parser.parseBuffer(testAudio)).rejects.toThrow('Failed to parse audio buffer');\n    });\n  });\n\n  describe('Performance and Memory', () => {\n    test('should handle large audio files efficiently', async () => {\n      const largeAudio = new Float32Array(44100 * 60); // 1 minute of audio\n      \n      // Fill with a realistic pattern\n      for (let i = 0; i < largeAudio.length; i++) {\n        largeAudio[i] = Math.sin(2 * Math.PI * 440 * i / 44100) * 0.1 + \n                        (Math.random() - 0.5) * 0.02;\n        \n        // Add beats every 0.5 seconds\n        if (i % 22050 === 0) {\n          largeAudio[i] = 0.8;\n        }\n      }\n      \n      const startTime = Date.now();\n      const result = await parser.parseBuffer(largeAudio, {\n        targetPictureCount: 20\n      });\n      const processingTime = Date.now() - startTime;\n      \n      expect(result.beats).toBeDefined();\n      expect(result.beats.length).toBeLessThanOrEqual(20);\n      expect(processingTime).toBeLessThan(30000); // Should complete within 30 seconds\n    });\n\n    test('should cleanup resources properly', async () => {\n      const plugin = createTestPlugin('cleanup-test');\n      parser.addPlugin(plugin);\n      \n      const testAudio = new Float32Array(4096).fill(0.1);\n      await parser.parseBuffer(testAudio);\n      \n      await parser.cleanup();\n      expect(plugin.cleanup).toHaveBeenCalled();\n    });\n  });\n\n  describe('Real-world Scenarios', () => {\n    test('should handle silence audio', async () => {\n      const silenceAudio = new Float32Array(44100).fill(0); // 1 second of silence\n      \n      const result = await parser.parseBuffer(silenceAudio, {\n        targetPictureCount: 5\n      });\n      \n      // Should still return a result, but with low confidence beats\n      expect(result.beats).toBeDefined();\n      if (result.beats.length > 0) {\n        result.beats.forEach(beat => {\n          expect(beat.confidence).toBeLessThan(0.5); // Low confidence for silence\n        });\n      }\n    });\n\n    test('should handle highly dynamic audio', async () => {\n      const dynamicAudio = new Float32Array(44100 * 3); // 3 seconds\n      \n      // Create highly dynamic audio with varying amplitudes\n      for (let i = 0; i < dynamicAudio.length; i++) {\n        const t = i / 44100;\n        const amplitude = 0.1 + 0.8 * Math.sin(2 * Math.PI * 0.5 * t); // Varying amplitude\n        const frequency = 440 + 220 * Math.sin(2 * Math.PI * 0.2 * t); // Varying frequency\n        dynamicAudio[i] = amplitude * Math.sin(2 * Math.PI * frequency * t);\n        \n        // Add clear beats\n        if (Math.floor(t) !== Math.floor((i - 1) / 44100)) {\n          dynamicAudio[i] = 0.9;\n        }\n      }\n      \n      const result = await parser.parseBuffer(dynamicAudio, {\n        targetPictureCount: 8\n      });\n      \n      expect(result.beats).toBeDefined();\n      expect(result.beats.length).toBeGreaterThan(0);\n      expect(result.beats.length).toBeLessThanOrEqual(8);\n    });\n\n    test('should maintain temporal accuracy', async () => {\n      const testAudio = new Float32Array(44100 * 5); // 5 seconds\n      const expectedBeatTimes = [1.0, 2.0, 3.0, 4.0]; // Clear beats every second\n      \n      // Create audio with beats at exact times\n      for (const beatTime of expectedBeatTimes) {\n        const startIdx = Math.floor(beatTime * 44100);\n        const endIdx = startIdx + Math.floor(0.05 * 44100); // 50ms beat\n        \n        for (let i = startIdx; i < endIdx && i < testAudio.length; i++) {\n          const t = (i - startIdx) / 44100;\n          testAudio[i] = Math.sin(2 * Math.PI * 60 * t) * Math.exp(-t * 20); // Decaying sine\n        }\n      }\n      \n      const result = await parser.parseBuffer(testAudio, {\n        targetPictureCount: 10\n      });\n      \n      // Check that detected beats are reasonably close to expected times\n      for (const expectedTime of expectedBeatTimes) {\n        const nearbyBeats = result.beats.filter(beat => \n          Math.abs(beat.timestamp - expectedTime) < 0.2 // Within 200ms\n        );\n        expect(nearbyBeats.length).toBeGreaterThan(0);\n      }\n    });\n  });\n});